# Дерево Фенвика

Дан массив размера **n**, необходимо выполнять две операции:
* **upd(pos, val)** - прибавить к элементу на позиции **pos** значение **val**;
* **get(pos)** - вывести сумму на отрезке **[0; pos]**.

***

## Как выглядит дерево

Построим дерево на **n** вершинах по следующему правилу: ребро **(u, v)** существует тогда и только тогда, когда `v = u | (u + 1)`.

![Дерево Фенвика](https://sun9-32.userapi.com/c857124/v857124430/1664db/DMxB7o8VRqw.jpg)

Посмотрим на вершину **u**. Пусть **v** - потомок **u**, имеющий наименьший номер. Будем хранить **t[u]** как сумму на отрезке **[v; u]**. Заметим, что **v = u & (u + 1)**, это пригодится при реализации алгоритма нахождения суммы.

***

## Запрос обновления
Чтобы сделать операцию **upd(pos, val)** нужно для каждой такой **u**, что **u** - предок **pos**, увеличить значение **t[u]** на **val**. Чтобы перебрать всех предков достаточно подниматься по рёбрам дерева вверх.

Например, при обновлении **upd(0, val)** мы изменим элементы **t[0], t[1], t[3], t[7]**.
```c++
void upd (int pos, int val) {
        while (pos < n) {
            t[pos] += val; // обновили сумму поддерева t[pos]
            pos |= pos + 1; // перешли в предка pos
        }
    }
```

***

## Запрос суммы
Чтобы сделать операцию **get(pos)** поступим следующим образом: прибавим к ответу **t[pos]**, затем перейдём в вершину **pos & (pos + 1) - 1** (помним, что **pos & (pos + 1)** - наименьший потомок **pos**), которая будет являться самой правой вершиной, находящейся левее **pos** и не являющейся её потомком.

Например, для отрезка **[0; 7]** ответом будет **t[7]**, а для отрезка **[0; 6] - t[6] + t[5] + t[3]**.
```c++
int get (int pos) {
        int result = 0;
        while (pos != -1) {
            result += t[pos]; // прибавили к ответу поддерево t[pos]
            pos &= pos + 1; // перешли в самого левого потомка
            pos--; // перешли в вершину левее
        }
        return result;
    }
```

## Время работы:
Посмотрим на две битовые операции: 
* `u = u | (u + 1)` - эта операция эквивалентна замене первого нулевого бита числа **u** на единицу. Например, 1100111 превратится в 1101111.
* `u = u & (u + 1) - 1` - эта операция эквивалентна следующей последовательности действий: взять число **u** (пусть у него **k** первых битов равны 1, затем идут **m** битов, равных 0), заменить **k+m** битов на 1, а следующий бит после них - на 0. Например, 1100111 превратится в 1011111.
* при запросах обновления используется операция, меняющая первый ненулевой бит числа.
* при запросах суммы используется операция, увеличивающая количество ненулевых битов в начале числа. 

Так как количество битов в числе **n** равняется **log n**, оба запроса выполняются за **O (log n)**.

***

[Реализация](/algomusya/algos/fenwick_tree.cpp)
